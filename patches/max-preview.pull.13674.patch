From 9d9fac76d3849ad116cbfed1b61f9d3ebe6aa49d Mon Sep 17 00:00:00 2001
From: Olivier Paroz <github@oparoz.com>
Date: Mon, 26 Jan 2015 15:25:45 +0100
Subject: [PATCH] Introducing the maximum size preview

The first time we're asked to generate a preview we'll generate one of
the maximum dimension indicated in the configuration and all future
resizing requests will be done on that preview in order to not waste
time converting the same file over and over
---
 config/config.sample.php |   4 +-
 lib/private/preview.php  | 286 ++++++++++++++++++++++++++++++++---------------
 tests/lib/preview.php    |  38 +++----
 3 files changed, 219 insertions(+), 109 deletions(-)

diff --git a/config/config.sample.php b/config/config.sample.php
index 2513a26..da97fbc 100644
--- a/config/config.sample.php
+++ b/config/config.sample.php
@@ -608,12 +608,12 @@
  * The maximum width, in pixels, of a preview. A value of ``null`` means there
  * is no limit.
  */
-'preview_max_x' => null,
+'preview_max_x' => 2048,
 /**
  * The maximum height, in pixels, of a preview. A value of ``null`` means there
  * is no limit.
  */
-'preview_max_y' => null,
+'preview_max_y' => 2048,
 /**
  * If a lot of small pictures are stored on the ownCloud instance and the
  * preview system generates blurry previews, you might want to consider setting
diff --git a/lib/private/preview.php b/lib/private/preview.php
index c7ef006..4cbae22 100644
--- a/lib/private/preview.php
+++ b/lib/private/preview.php
@@ -2,6 +2,7 @@
 /**
  * Copyright (c) 2013 Frank Karlitschek frank@owncloud.org
  * Copyright (c) 2013 Georg Ehrke georg@ownCloud.com
+ * Copyright (c) 2015 Olivier Paroz owncloud@interfasys.ch
  * This file is licensed under the Affero General Public License version 3 or
  * later.
  * See the COPYING-README file.
@@ -81,8 +82,8 @@ public function __construct($user = '', $root = '/', $file = '', $maxX = 1, $max
 		$this->userView = new \OC\Files\View('/' . $user);

 		//set config
-		$this->configMaxX = \OC_Config::getValue('preview_max_x', null);
-		$this->configMaxY = \OC_Config::getValue('preview_max_y', null);
+		$this->configMaxX = \OC_Config::getValue('preview_max_x', 2048);
+		$this->configMaxY = \OC_Config::getValue('preview_max_y', 2048);
 		$this->maxScaleFactor = \OC_Config::getValue('preview_max_scale_factor', 2);

 		//save parameters
@@ -347,7 +348,8 @@ public function deleteAllPreviews() {
 	}

 	/**
-	 * check if thumbnail or bigger version of thumbnail of file is cached
+	 * Checks if thumbnail or bigger version of thumbnail of file is already cached
+	 *
 	 * @param int $fileId fileId of the original image
 	 * @return string|false path to thumbnail if it exists or false
 	 */
@@ -356,9 +358,11 @@ public function isCached($fileId) {
 			return false;
 		}

+		// This gives us a calculated path to a preview of asked dimensions
+		// thumbnailFolder/fileId/my_image-<maxX>-<maxY>.png
 		$preview = $this->buildCachePath($fileId);

-		//does a preview with the wanted height and width already exist?
+		// This checks if a preview exists at that location
 		if ($this->userView->file_exists($preview)) {
 			return $preview;
 		}
@@ -367,24 +371,23 @@ public function isCached($fileId) {
 	}

 	/**
-	 * check if a bigger version of thumbnail of file is cached
+	 * Checks if a bigger version of a file preview is cached and if not
+	 * return the preview of max allowed dimensions
+	 *
 	 * @param int $fileId fileId of the original image
+	 *
 	 * @return string|false path to bigger thumbnail if it exists or false
-	*/
+	 */
 	private function isCachedBigger($fileId) {

 		if (is_null($fileId)) {
 			return false;
 		}

-		// in order to not loose quality we better generate aspect preserving previews from the original file
-		if ($this->keepAspect) {
-			return false;
-		}
-
 		$maxX = $this->getMaxX();

 		//array for usable cached thumbnails
+		// FIXME: Checking only the width could lead to issues
 		$possibleThumbnails = $this->getPossibleThumbnails($fileId);

 		foreach ($possibleThumbnails as $width => $path) {
@@ -395,6 +398,12 @@ private function isCachedBigger($fileId) {
 			}
 		}

+		// At this stage, we didn't find a preview, so if the folder is not empty,
+		// we return the max preview we generated on the first run
+		if ($possibleThumbnails) {
+			return $possibleThumbnails['max'];
+		}
+
 		return false;
 	}

@@ -411,7 +420,7 @@ private function getPossibleThumbnails($fileId) {

 		$previewPath = $this->getPreviewPath($fileId);

-		$wantedAspectRatio = (float) ($this->getMaxX() / $this->getMaxY());
+		$wantedAspectRatio = (float)($this->getMaxX() / $this->getMaxY());

 		//array for usable cached thumbnails
 		$possibleThumbnails = array();
@@ -419,6 +428,11 @@ private function getPossibleThumbnails($fileId) {
 		$allThumbnails = $this->userView->getDirectoryContent($previewPath);
 		foreach ($allThumbnails as $thumbnail) {
 			$name = rtrim($thumbnail['name'], '.png');
+			// Always add the max preview to the array
+			if (strpos($name, 'max')) {
+				$possibleThumbnails['max'] = $thumbnail['path'];
+				continue;
+			}
 			list($x, $y, $aspectRatio) = $this->getDimensionsFromFilename($name);

 			if (abs($aspectRatio - $wantedAspectRatio) >= 0.000001
@@ -472,7 +486,11 @@ private function unscalable($x, $y) {
 	}

 	/**
-	 * return a preview of a file
+	 * Returns a preview of a file
+	 *
+	 * The cache is searched first and if nothing usable was found then a preview is
+	 * generated by one of the providers
+	 *
 	 * @return \OC_Image
 	 */
 	public function getPreview() {
@@ -482,67 +500,23 @@ public function getPreview() {

 		$this->preview = null;
 		$file = $this->getFile();
-		$maxX = $this->getMaxX();
-		$maxY = $this->getMaxY();
-		$scalingUp = $this->getScalingUp();

 		$fileInfo = $this->getFileInfo($file);
-		if($fileInfo === null || $fileInfo === false) {
+		if ($fileInfo === null || $fileInfo === false) {
 			return new \OC_Image();
 		}
-		$fileId = $fileInfo->getId();

+		$fileId = $fileInfo->getId();
 		$cached = $this->isCached($fileId);
 		if ($cached) {
-			$stream = $this->userView->fopen($cached, 'r');
-			$this->preview = null;
-			if ($stream) {
-				$image = new \OC_Image();
-				$image->loadFromFileHandle($stream);
-				$this->preview = $image->valid() ? $image : null;
-
-				$this->resizeAndCrop();
-				fclose($stream);
-			}
+			$this->getCachedPreview($fileId, $cached);
 		}

 		if (is_null($this->preview)) {
-			$preview = null;
-
-			foreach (self::$providers as $supportedMimeType => $provider) {
-				if (!preg_match($supportedMimeType, $this->mimeType)) {
-					continue;
-				}
-
-				\OC_Log::write('core', 'Generating preview for "' . $file . '" with "' . get_class($provider) . '"', \OC_Log::DEBUG);
-
-				/** @var $provider Provider */
-				$preview = $provider->getThumbnail($file, $maxX, $maxY, $scalingUp, $this->fileView);
-
-				if (!($preview instanceof \OC_Image)) {
-					continue;
-				}
-
-				$this->preview = $preview;
-				$this->resizeAndCrop();
-
-				$previewPath = $this->getPreviewPath($fileId);
-				$cachePath = $this->buildCachePath($fileId);
-
-				if ($this->userView->is_dir($this->getThumbnailsFolder() . '/') === false) {
-					$this->userView->mkdir($this->getThumbnailsFolder() . '/');
-				}
-
-				if ($this->userView->is_dir($previewPath) === false) {
-					$this->userView->mkdir($previewPath);
-				}
-
-				$this->userView->file_put_contents($cachePath, $preview->data());
-
-				break;
-			}
+			$this->generatePreview($fileId);
 		}

+		// We still don't have a preview, so we generate an empty object which can't be displayed
 		if (is_null($this->preview)) {
 			$this->preview = new \OC_Image();
 		}
@@ -570,6 +544,47 @@ public function showPreview($mimeType = null) {
 	}

 	/**
+	 * Retrieves the preview from the cache and resizes it if necessary
+	 *
+	 * @param int $fileId fileId of the original image
+	 * @param string $cached the path to the cached preview
+	 */
+	private function getCachedPreview($fileId, $cached) {
+		$stream = $this->userView->fopen($cached, 'r');
+		$this->preview = null;
+		if ($stream) {
+			$image = new \OC_Image();
+			$image->loadFromFileHandle($stream);
+
+			$this->preview = $image->valid() ? $image : null;
+
+			$maxX = (int)$this->getMaxX();
+			$maxY = (int)$this->getMaxY();
+			$previewX = (int)$this->preview->width();
+			$previewY = (int)$this->preview->height();
+
+			if ($previewX !== $maxX && $previewY !== $maxY) {
+				$this->resizeAndStore($fileId);
+			}
+
+			fclose($stream);
+		}
+	}
+
+	/**
+	 * Resizes, crops, fixes orientation and stores in the cache
+	 *
+	 * @param int $fileId fileId of the original image
+	 */
+	private function resizeAndStore($fileId) {
+		// Resize and store
+		$this->resizeAndCrop();
+		// We save a copy in the cache to speed up future calls
+		$cachePath = $this->buildCachePath($fileId);
+		$this->userView->file_put_contents($cachePath, $this->preview->data());
+	}
+
+	/**
 	 * resize, crop and fix orientation
 	 * @return void
 	 */
@@ -599,6 +614,7 @@ private function resizeAndCrop() {
 			}
 		}

+		// The preview already has the asked dimensions
 		if ($x === $realX && $y === $realY) {
 			$this->preview = $image;
 			return;
@@ -631,11 +647,13 @@ private function resizeAndCrop() {

 		$image->preciseResize($newXSize, $newYSize);

+		// The preview has been upscaled and now has the asked dimensions
 		if ($newXSize === $x && $newYSize === $y) {
 			$this->preview = $image;
 			return;
 		}

+		// One dimension of the upscaled preview is too big
 		if ($newXSize >= $x && $newYSize >= $y) {
 			$cropX = floor(abs($x - $newXSize) * 0.5);
 			//don't crop previews on the Y axis, this sucks if it's a document.
@@ -648,6 +666,7 @@ private function resizeAndCrop() {
 			return;
 		}

+		// One dimension of the upscaled preview is too small and we're allowed to scale up
 		if (($newXSize < $x || $newYSize < $y) && $scalingUp) {
 			if ($newXSize > $x) {
 				$cropX = floor(($newXSize - $x) * 0.5);
@@ -680,11 +699,128 @@ private function resizeAndCrop() {
 			$image = new \OC_Image($backgroundLayer);

 			$this->preview = $image;
+
 			return;
 		}
 	}

 	/**
+	 * Returns the path to a preview based on its dimensions and aspect
+	 *
+	 * @param int $fileId
+	 *
+	 * @return string
+	 */
+	private function buildCachePath($fileId) {
+		$maxX = $this->getMaxX();
+		$maxY = $this->getMaxY();
+
+		$previewPath = $this->getPreviewPath($fileId);
+		$previewPath = $previewPath . strval($maxX) . '-' . strval($maxY);
+		if ($this->keepAspect) {
+			$previewPath .= '-with-aspect';
+		}
+		$previewPath .= '.png';
+
+		return $previewPath;
+	}
+
+	/**
+	 * @param int $fileId
+	 *
+	 * @return string
+	 */
+	private function getPreviewPath($fileId) {
+		return $this->getThumbnailsFolder() . '/' . $fileId . '/';
+	}
+
+	/**
+	 * Asks the provider to send a preview of the file of maximum dimensions
+	 * and after saving it in the cache, it is then resized to the asked dimensions
+	 *
+	 * This is only called once in order to generate a large PNG of dimensions defined in the
+	 * configuration file. We'll be able to quickly resize it later on.
+	 * We never upscale the original conversion as this will be done later by the resizing operation
+	 *
+	 * @param int $fileId fileId of the original image
+	 */
+	private function generatePreview($fileId) {
+		$file = $this->getFile();
+		$preview = null;
+
+		foreach (self::$providers as $supportedMimeType => $provider) {
+			if (!preg_match($supportedMimeType, $this->mimeType)) {
+				continue;
+			}
+
+			\OC_Log::write(
+				'core', 'Generating preview for "' . $file . '" with "' . get_class($provider)
+						. '"', \OC_Log::DEBUG
+			);
+
+			// TODO Bitmap previews have to also be limited in order to maximise the benefits
+			/** @var $provider Provider */
+			$preview = $provider->getThumbnail(
+				$file, $this->configMaxX, $this->configMaxY, $scalingUp = false, $this->fileView
+			);
+
+			if (!($preview instanceof \OC_Image)) {
+				continue;
+			}
+
+			$this->preview = $preview;
+			$previewPath = $this->getPreviewPath($fileId);
+
+			if ($this->userView->is_dir($this->getThumbnailsFolder() . '/') === false) {
+				$this->userView->mkdir($this->getThumbnailsFolder() . '/');
+			}
+
+			if ($this->userView->is_dir($previewPath) === false) {
+				$this->userView->mkdir($previewPath);
+			}
+
+			// This stores our large preview so that it can be used in subsequent resizing requests
+			$this->storeMaxPreview($previewPath);
+
+			break;
+		}
+
+		// The providers have been kind enough to give us a preview
+		if ($preview) {
+			$this->resizeAndStore($fileId);
+		}
+	}
+
+	/**
+	 * Stores the max preview in the cache
+	 *
+	 * @param string $previewPath path to the preview
+	 */
+	private function storeMaxPreview($previewPath) {
+		$maxPreview = false;
+		$preview = $this->preview;
+
+		$allThumbnails = $this->userView->getDirectoryContent($previewPath);
+		// This is so that the cache doesn't need emptying when upgrading
+		// Can be replaced by an upgrade script...
+		foreach ($allThumbnails as $thumbnail) {
+			$name = rtrim($thumbnail['name'], '.png');
+			if (strpos($name, 'max')) {
+				$maxPreview = true;
+				break;
+			}
+		}
+		// We haven't found the max preview, so we create it
+		if (!$maxPreview) {
+			$maxX = $preview->width();
+			$maxY = $preview->height();
+			$previewPath = $previewPath . strval($maxX) . '-' . strval($maxY);
+			$previewPath .= '-max.png';
+			$this->userView->file_put_contents($previewPath, $preview->data());
+		}
+	}
+
+	/**
 	 * register a new preview provider to be used
 	 * @param string $class
 	 * @param array $options
@@ -966,30 +1102,4 @@ public static function isMimeSupported($mimeType) {
 		return false;
 	}

-	/**
-	 * @param int $fileId
-	 * @return string
-	 */
-	private function buildCachePath($fileId) {
-		$maxX = $this->getMaxX();
-		$maxY = $this->getMaxY();
-
-		$previewPath = $this->getPreviewPath($fileId);
-		$preview = $previewPath . strval($maxX) . '-' . strval($maxY);
-		if ($this->keepAspect) {
-			$preview .= '-with-aspect';
-		}
-		$preview .= '.png';
-
-		return $preview;
-	}
-
-
-	/**
-	 * @param int $fileId
-	 * @return string
-	 */
-	private function getPreviewPath($fileId) {
-		return $this->getThumbnailsFolder() . '/' . $fileId . '/';
-	}
 }
